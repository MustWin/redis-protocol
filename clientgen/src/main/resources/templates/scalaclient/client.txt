package com.twitter.finagle.redis

import com.google.common.base.Charsets

import com.twitter.finagle.Service
import com.twitter.finagle.builder.ClientBuilder
import com.twitter.util.Future

import org.jboss.netty.buffer.ChannelBuffers

import redis._
import redis.netty._

import scala.collection.mutable.ArrayBuffer

object RedisClient {

  /**
   * Construct a client from a single host.
   * @param host a String of host:port combination.
   */
  def apply(host: String): RedisClient = RedisClient(
    ClientBuilder()
      .hosts(host)
      .hostConnectionLimit(1)
      .codec(new RedisCodecFactory)
      .build())

  /**
   * Construct a client from a single Service.
   */
  def apply(service: Service[Command, Reply[_]]): RedisClient = new RedisClient(service)

  {{#commands}}
  val {{name}} = "{{name}}"
  val {{name}}_BYTES = ChannelBuffers.copiedBuffer({{name}}, Charsets.US_ASCII)

  {{/commands}}
}

case class RedisException(message:String) extends RuntimeException(message)

class RedisClient(service: Service[Command, Reply[_]]) {
  {{#commands}}

  /**
   * {{comment}}
   */
  def {{quote}}{{methodname}}{{quote}}({{#arguments}}{{^first}}, {{/first}}{{name}}: {{typename}}{{#multiple}}*{{/multiple}}{{/arguments}}): Future[{{reply}}{{#generic}}[_]{{/generic}}] = {
    {{#usearray}}
    var arguments = ArrayBuffer[Object]()
    {{#arguments}}
    {{#multiple}}
    arguments = arguments ++ {{name}}
    {{/multiple}}
    {{^multiple}}
    arguments += {{name}}
    {{/multiple}}
    {{/arguments}}
    service(new Command(RedisClient.{{name}}_BYTES, arguments.toArray)) map {
    {{/usearray}}
    {{^usearray}}
    service(new Command(RedisClient.{{name}}_BYTES{{#arguments}}, {{name}}{{/arguments}})) map {
    {{/usearray}}
      case error: ErrorReply => throw new RedisException(error.data())
      case reply: {{reply}}{{#generic}}[_]{{/generic}} => reply
      case other => throw new RedisException("Unexpected reply from {{name}}: " + other)
    }
  }
  {{/commands}}

  def release() {
    service.release()
  }
}
